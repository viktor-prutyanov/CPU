module top
(
    input CLK,
    
    output DS_EN1, DS_EN2, DS_EN3, DS_EN4,
    output DS_A, DS_B, DS_C, DS_D, DS_E, DS_F, DS_G,

    output D_EN1, D_EN2, D_EN3, D_EN4, output [7:0]LED,

    output FLASH_CLK, FLASH_CS, FLASH_DI,
    input FLASH_DO
);

//Status led

assign LED[7] = end_led;
reg end_led = 1'b0;

//Two 7 segment (total 4 bytes) indicators  

reg [31:0]seg_number = 32'hCCCCCCCC;

wire [15:0]num1 = seg_number[15:0];
segment_led segment_led0(
    .CLK(CLK),
    .DS_EN1(DS_EN1), .DS_EN2(DS_EN2), .DS_EN3(DS_EN3), .DS_EN4(DS_EN4),
    .DS_A(DS_A), .DS_B(DS_B), .DS_C(DS_C), .DS_D(DS_D), .DS_E(DS_E), .DS_F(DS_F), .DS_G(DS_G),
    .NUM(num1)
);

wire [15:0]num2 = seg_number[31:16];
segment_led segment_led1(
    .CLK(CLK),
    .DS_EN1(D_EN1), .DS_EN2(D_EN2), .DS_EN3(D_EN3), .DS_EN4(D_EN4),
    .DS_A(LED[0]), .DS_B(LED[1]), .DS_C(LED[2]), .DS_D(LED[3]), .DS_E(LED[4]), .DS_F(LED[5]), .DS_G(LED[6]),
    .NUM(num2)
);

//W25Q32BV flash memory 

wire flash_new_data1;
wire [15:0]flash_data1;
wire flash_idle;
flash_spi flash_spi0(
    .CLK(CLK),
    .FLASH_CLK(FLASH_CLK), .FLASH_CS(FLASH_CS), .FLASH_DI(FLASH_DI), .FLASH_DO(FLASH_DO),
    .NEW_DATA1(flash_new_data1),
    .DATA1(flash_data1),
    .IDLE(flash_idle)
);

reg [11:0]ram_addr = 12'b0;
wire [11:0]ram_address_sig = ram_addr;
reg [15:0]ram_data = 16'b0;
wire [15:0]ram_data_sig = ram_data;
reg ram_wren = 1'b0;
wire ram_wren_sig = ram_wren;
wire [15:0]ram_q;
ram ram_inst (
    .address(ram_address_sig),
    .clock(CLK),
    .data(ram_data_sig),
    .wren(ram_wren_sig),
    .q(ram_q)
);

reg [11:0]ip = 12'b0; //Instruction pointer 
reg [10:0]sp = 11'b0; //Stack pointer
wire [11:0]safe_sp = {1'b1, sp}; //Stack starts at 12'b1000_0000_0000 and ends at 12'hFF
(*keep*) reg [31:0]registers[7:0]; 

reg[8:0]state 
initial state = 9'b1_00000_000;
reg[6:0]load_cnt = 7'b0;
//reg [33:0]cnt = 34'b0;
always @(posedge CLK) begin
    case (state)
        9'b1_00000_000: begin
            ram_wren = 1'b0;
            if (flash_new_data1) begin
                ram_data = flash_data1;
                ram_addr[6:0] = load_cnt;
                load_cnt = load_cnt + 7'b1;
                if (load_cnt == 7'b0) begin
                    state <= 9'b1_00000_001;
                end
                ram_wren = 1'b1;
            end
        end
        // 9'b1_00000_001: begin
        //     ram_wren = 1'b0;
        //     ram_addr = 12'b0;
        //     state <= 9'b1_00000_010;
        // end
        // 9'b1_00000_010: begin
        //     cnt = cnt + 34'b1;
        //     seg_number[31:16] = ram_q;
        //     seg_number[15:0] = {9'b0, cnt[33:27]};
        //     ram_addr[11:0] = {5'b0, cnt[33:27]};
        // end
        9'b1_00000_001: begin
            ram_wren = 1'b0;
            ram_addr = 12'b0;//ip;
            state <= 9'b1_00000_010;
        end
        9'b1_00000_010: begin
            state <= 9'b1_00000_011;
        end
        9'b1_00000_011: begin
            state <= 9'b1_00000_100;
        end
        9'b1_00000_100: begin
            seg_number[31:16] = ram_q;
            seg_number[15:0] = 16'hEEEE;
        //     case (ram_q[15])
        //         1'b0: begin
        //             case (ram_q[14:13]) 
        //                 2'b00: begin
        //                     case (ram_q[12:11])
        //                         2'b00: begin
        //                             case (ram_q[4:2])
        //                                 3'b000: begin //NA
        //                                     case (ram_q[1:0])
        //                                 /*END*/ 2'b00: begin
        //                                             state <= 9'b0_00000_000;
        //                                         end 
        //                                 /*RET*/ 2'b01: begin
    
        //                                         end
        //                                 /*RST*/ 2'b10: begin
                                                    
        //                                         end 
        //                                 /*NOP*/ 2'b11: begin
        //                                             ip = ip + 12'b1;
        //                                             ram_addr = ip;
        //                                             state <= 9'b1_00000_011;
        //                                         end 
        //                                     endcase
        //                                 end
        //                                 3'b010: begin //R1
        //                                     case (ram_q[1:0])
        //                                 /*PUSH*/2'b00: begin
    
        //                                         end 
        //                                 /*POP*/ 2'b01: begin
    
        //                                         end
        //                                 /*IN*/  2'b10: begin
                                                    
        //                                         end 
        //                                 /*OUT*/ 2'b11: begin
        //                                             seg_number = registers[ram_q[10:8]];
        //                                             ip = ip + 12'b1;
        //                                             ram_addr = ip;
        //                                             state <= 9'b1_00000_011;
        //                                         end 
        //                                     endcase
        //                                 end
        //                                 3'b011: begin //R1
                                            
        //                                 end
        //                                 3'b100: begin //R2
                                            
        //                                 end
        //                             endcase
        //                         end
        //                         2'b01: begin
                                    
        //                         end
        //                         2'b10: begin
                                    
        //                         end
        //                     endcase
        //                 end
        //         /*MOVn*/2'b01: begin //RN
        //                     case (ram_q[12:11])
        //                 /*MOV0*/2'b00: begin
        //                             registers[ram_q[10:8]][7:0] = ram_q[7:0];
        //                         end
        //                 /*MOV1*/2'b01: begin
        //                             registers[ram_q[10:8]][15:8] = ram_q[7:0];
        //                         end
        //                 /*MOV2*/2'b10: begin
        //                             registers[ram_q[10:8]][23:16] = ram_q[7:0];
        //                         end
        //                 /*MOV3*/2'b11: begin
        //                             registers[ram_q[10:8]][31:24] = ram_q[7:0];
        //                         end
        //                     endcase 
        //                     ip = ip + 12'b1;
        //                     ram_addr = ip;
        //                     state <= 9'b1_00000_011;
        //                 end
        //                 2'b10: begin //RN
                            
        //                 end
        //             endcase
        //         end
        //         1'b1: begin
        //             // case (ram_q[14:12])
        //             // endcase
        //         end
        //     endcase
        end
/*END*/ 9'b0_00000_000: begin
            end_led = 1'b1;
        end
    endcase
end

endmodule
